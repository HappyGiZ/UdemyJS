'use strict';

// !_________________________УСЛОВНОЕ ВЕТВЛЕНИЕ: if, '?'

let message;
let login = prompt('ваш логин');

// несколько условий if else
if (login == 'Сотрудник') {
    message = 'Привет';
} else if (login == 'Директор') {
    message = 'Здравствуйте';
} else if (login == '') {
    message = 'Нет логина';
} else {
    message = '';
}

// Несколько операторов „?“
// login == ('Сотрудник') ? 'Hi!' :
//     ('Директор') ? 'Здравствуйте' :
//         ('') ? 'Нет логина' : '';
// alert(message);

// !_________________________КОНСТРУКЦИЯ SWITCH

// берем переменную х
let x = 3;
// записываем её аргументом в конструкцию switch
switch (x) {
    // проверяем строгое соответствие кейсу (аналог if)
    case 2:
        // если соответствие найдено, выполняется тело
        console.log('Вариант 1');
        break;
    // если совпадение не найдено, переходим к следующему кейсу
    case 4:
        console.log('Вариант 2');
        break;
    // если ни один кейс не совпал, выполняется (необязательный) default
    default:
        console.log('Нет подходящих вариантов');
        break;
    // Если break нет, то выполнение пойдёт ниже по следующим case, при этом остальные проверки игнорируются
}

// !_________________________ЦИКЛЫ

// while
let i = 0;
while (i < 3) {
    alert(`number ${i}!`);
    i++;
}

// do...while
// выполняет тело цикла пока введеное число меньше 100
// прерывает цикл, введеное число больше 100, или нажата отмена
let num;
do {
    num = prompt("Введите число больше 100?", 0);
} while (num <= 100 && num);

// for
for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
    alert(i);
}

// использование continue для вывода только нечетных значений
for (let i = 0; i < 10; i++) {
    // если true, пропустить оставшуюся часть тела цикла
    if (i % 2 == 0) {
        continue;
    }
    alert(i); // 1, затем 3, 5, 7, 9
}

// метка для break/continue
outer: for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {

        let input = prompt(`Значение на координатах (${i},${j})`, '');
        // если пустая строка или Отмена, то выйти из обоих циклов
        if (!input) {
            break outer;    // <---
        }   // сделать что-нибудь со значениями...
    }
}
alert('Готово!');

// поиск простых чисел
let n = 20;
again: for (let i = 2; i <= n; i++) {   // Для всех i...
    for (let j = 2; j < i; j++) {   // проверить, делится ли число..
        if (i % j == 0) {
            continue again; // не подходит, берём следующее
        }
    }
    console.log(i);
}


// !_________________________ОБЪЕКТЫ

// объект
const options = {
    name: 'test',
    width: 500,
    height: 500,
    colors: {
        border: 'black',
        background: 'red'
    },
    makeTest: function () {
        console.log('TesT');    //функция внутри объекта
    }
};

// вывод ключей и значений объекта
for (let key in options) {
    if (typeof (options[key]) === 'object') {
        console.log(`Объект: ${key} включает в себя:`);
        for (let i in options[key]) {
            console.log(`   Cвойство: ${i}, со значением: ${options[key][i]};`);
        }
    } else {
        console.log(`Cвойство: ${key}, имеет значение: ${options[key]};`);
    }
}

// количество ключей в объекте
console.log(Object.keys(options).length);

// запуск функции из объекта
options.makeTest();

// удаление свойства объекта (ключ+значения)
delete options.height;

// деструктуризация объекта
const { border, background } = options.colors;
console.log(border);



// !_________________________МАССИВЫ

// массив
const arr = [1, 2, 3, 4, 5, 6, 7];

// удаление последнего элемента массива
arr.pop();

// добавление указанного элемента в конец массива
arr.push(33);

// перебор массива обычным циклом
for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
}

// перебор массива методом for ... of (позволяет использовать break и continue)
// value - перебираемый элемент массива
// arr - массив в котором происходит перебор
for (let value of arr) {
    console.log(value);
}

// перебор массива методом forEachs
// item - перебираемый элемент массива
// i - номер позиции элемента
// arr - массив в котором происходит перебор
arr.forEach(function (item, i, arr) {
    console.log(`Элемент на позиции ${i}: ${item} (внутри массива ${arr})`);
});

// сортировка массива по алфавиту
// 1 - задаём вопрос пользователю 
// 2 - в ответ получаем строку с ответами, записанными через указанный разделитель
// 3 - сортируем массив по алфавиту
// 4 - выводим полученный массив строкой через указанный разделитель
const str = prompt('', '');
const products = str.split(', ');
products.sort();
console.log(products.join('; '));

// сортировка массива в порядке возрастания
// 1 - используем метод сортировки в алфавитном порядке, вызывая функцию
// 2 - функция сравнения
const array = [2, 13, 26, 8, 10];
array.sort(compareNum);
console.log(array);
function compareNum(a, b) {
    return a - b;
}

// !_________________________ФУНКЦИИ
// function sum(a, b) - параметры функции
// b = "текст не добавлен" - указание параметра по умолчанию
// sum(1, 2); - аргументы функции
// функция может вернуть результат, который будет передан в вызвавший её код
// функция может использовать и изменять глобальные (внешние) переменные
// если у глобальных и локальных переменных одинаковое имя, используется локальная
function sum(a, b = "текст не добавлен") {
    return a + b;
}

let result = sum(1, 2);
alert(result);

// !_________________________МЕТОДЫ ОБЪЕКТА, THIS

let user = {
    name: "Джон",
    age: 30
};

user.sayHi = function () {
    alert("Привет!");
};

user.sayHi();
// Итак, мы получили метод sayHi объекта user.

let obj,
    method;

obj = {
    go: function () {
        alert(this);
    }
};

// Это обычный вызов метода объекта через точку ., и this ссылается на объект перед точкой.
obj.go();               // (1) [object Object]

// Здесь то же самое. Круглые скобки (оператор группировки) тут не изменяют порядок
// выполнения операций – доступ к методу через точку в любом случае срабатывает первым.
(obj.go)();             // (2) [object Object]

// Здесь мы имеем более сложный вызов (expression).method(). 
// Такой вызов работает, как если бы он был разделён на 2 строчки:
// f = obj.go; — вычисляется выражение (переменная f ссылается на код функции)
// f();        — вызов функции, на которую ссылается f
method = obj.go();    // (3) undefined

// Тут похожая ситуация на случай (3) – идёт потеря значения this.
(obj.go || obj.stop)(); // (4) undefined


// !_________________________ОПЦИОНАЛЬНАЯ ЦЕПОЧКА ?.

// Синтаксис опциональной цепочки ?. имеет три формы:

// obj?.prop – возвращает obj.prop, если существует obj, и undefined в противном случае.
// obj?.[prop] – возвращает obj[prop], если существует obj, и undefined в противном случае.
// obj.method?.() – вызывает obj.method(), если существует obj.method, в противном случае возвращает undefined.
// т.е. ?. проверяет левую часть выражения на равенство null/undefined,
// и продолжает дальнейшее вычисление, только если это не так.
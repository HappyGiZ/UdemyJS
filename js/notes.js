'use strict';

// !_________________________УСЛОВНОЕ ВЕТВЛЕНИЕ: if, '?'

let message;
let login = prompt('ваш логин');

// несколько условий if else
if (login == 'Сотрудник') {
    message = 'Привет';
} else if (login == 'Директор') {
    message = 'Здравствуйте';
} else if (login == '') {
    message = 'Нет логина';
} else {
    message = '';
}

// Несколько операторов „?“
// login == ('Сотрудник') ? 'Hi!' :
//     ('Директор') ? 'Здравствуйте' :
//         ('') ? 'Нет логина' : '';
// alert(message);

// !_________________________КОНСТРУКЦИЯ SWITCH

// берем переменную х
let x = 3;
// записываем её аргументом в конструкцию switch
switch (x) {
    // проверяем строгое соответствие кейсу (аналог if)
    case 2:
        // если соответствие найдено, выполняется тело
        console.log('Вариант 1');
        break;
    // если совпадение не найдено, переходим к следующему кейсу
    case 4:
        console.log('Вариант 2');
        break;
    // если ни один кейс не совпал, выполняется (необязательный) default
    default:
        console.log('Нет подходящих вариантов');
        break;
    // Если break нет, то выполнение пойдёт ниже по следующим case, при этом остальные проверки игнорируются
}

// !_________________________ЦИКЛЫ

// while
let i = 0;

while (i < 3) {
    alert(`number ${i}!`);
    i++;
}

// do...while
// выполняет тело цикла пока введеное число меньше 100
// прерывает цикл, введеное число больше 100, или нажата отмена
let num;

do {
    num = prompt("Введите число больше 100?", 0);
} while (num <= 100 && num);

// for
for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
    alert(i);
}

// использование continue для вывода только нечетных значений
for (let i = 0; i < 10; i++) {
    // если true, пропустить оставшуюся часть тела цикла
    if (i % 2 == 0) {
        continue;
    }
    alert(i); // 1, затем 3, 5, 7, 9
}

// метка для break/continue
outer: for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {

        let input = prompt(`Значение на координатах (${i},${j})`, '');
        // если пустая строка или Отмена, то выйти из обоих циклов
        if (!input) {
            break outer;    // <---
        }   // сделать что-нибудь со значениями...
    }
}
alert('Готово!');

// поиск простых чисел
let n = 20;
again: for (let i = 2; i <= n; i++) {   // Для всех i...
    for (let j = 2; j < i; j++) {   // проверить, делится ли число..
        if (i % j == 0) {
            continue again; // не подходит, берём следующее
        }
    }
    console.log(i);
}


// !_________________________ОБЪЕКТЫ

// объект
const options = {
    name: 'test',
    width: 500,
    height: 500,
    colors: {
        border: 'black',
        background: 'red'
    },
    makeTest: function () {
        console.log('TesT');    //функция внутри объекта
    }
};

// вывод ключей и значений объекта
for (let key in options) {
    if (typeof (options[key]) === 'object') {
        console.log(`Объект: ${key} включает в себя:`);
        for (let i in options[key]) {
            console.log(`   Cвойство: ${i}, со значением: ${options[key][i]};`);
        }
    } else {
        console.log(`Cвойство: ${key}, имеет значение: ${options[key]};`);
    }
}

// количество ключей в объекте
console.log(Object.keys(options).length);

// запуск функции из объекта
options.makeTest();

// удаление свойства объекта (ключ+значения)
delete options.height;

// деструктуризация объекта
const { border, background } = options.colors;
console.log(border);



// !_________________________МАССИВЫ

// массив
const arr = [1, 2, 3, 4, 5, 6, 7];

// удаление последнего элемента массива
arr.pop();

// добавление указанного элемента в конец массива
arr.push(33);

// перебор массива обычным циклом
for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
}

//? перебор массива методом for ... of (позволяет использовать break и continue)
// value - перебираемый элемент массива
// arr - массив в котором происходит перебор
for (let value of arr) {
    console.log(value);
}

//? перебор массива методом forEachs
// item - перебираемый элемент массива
// i - номер позиции элемента
// arr - массив в котором происходит перебор
arr.forEach(function (item, i, arr) {
    console.log(`Элемент на позиции ${i}: ${item} (внутри массива ${arr})`);
});

//? сортировка массива по алфавиту
// 1 - задаём вопрос пользователю 
// 2 - в ответ получаем строку с ответами, записанными через указанный разделитель
// 3 - сортируем массив по алфавиту
// 4 - выводим полученный массив строкой через указанный разделитель
const str = prompt('', '');
const products = str.split(', ');
products.sort();
console.log(products.join('; '));

//? сортировка массива в порядке возрастания
// 1 - используем метод сортировки в алфавитном порядке, вызывая функцию
// 2 - функция сравнения
const array = [2, 13, 26, 8, 10];
array.sort(compareNum);
console.log(array);
function compareNum(a, b) {
    return a - b;
}

// Методы arr.reduce и arr.reduceRight похожи на методы выше, но они немного сложнее. Они используются для вычисления какого-нибудь единого значения на основе всего массива.

Синтаксис:

let value = arr.reduce(function (previousValue, item, index, array) {
    // ...
}, [initial]);

// Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.

Аргументы:

// previousValue – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial),
// item – очередной элемент массива,
// index – его индекс,
// array – сам массив.


// !_________________________ФУНКЦИИ
// function sum(a, b) - параметры функции
// b = "текст не добавлен" - указание параметра по умолчанию
// sum(1, 2); - аргументы функции
// функция может вернуть результат, который будет передан в вызвавший её код
// функция может использовать и изменять глобальные (внешние) переменные
// если у глобальных и локальных переменных одинаковое имя, используется локальная
function sum(a, b = "текст не добавлен") {
    return a + b;
}

let result = sum(1, 2);
alert(result);


// !_________________________МЕТОДЫ ОБЪЕКТА, THIS

let user = {
    name: "Джон",
    age: 30
};

user.sayHi = function () {
    alert("Привет!");
};

user.sayHi();
// Итак, мы получили метод sayHi объекта user.

let obj,
    method;

obj = {
    go: function () {
        alert(this);
    }
};

// Это обычный вызов метода объекта через точку ., и this ссылается на объект перед точкой.
obj.go();               // (1) [object Object]

// Здесь то же самое. Круглые скобки (оператор группировки) тут не изменяют порядок
// выполнения операций – доступ к методу через точку в любом случае срабатывает первым.
(obj.go)();             // (2) [object Object]

// Здесь мы имеем более сложный вызов (expression).method(). 
// Такой вызов работает, как если бы он был разделён на 2 строчки:
// f = obj.go; — вычисляется выражение (переменная f ссылается на код функции)
// f();        — вызов функции, на которую ссылается f
method = obj.go();    // (3) undefined

// Тут похожая ситуация на случай (3) – идёт потеря значения this.
(obj.go || obj.stop)(); // (4) undefined


// !_________________________ОПЦИОНАЛЬНАЯ ЦЕПОЧКА ?.

// Синтаксис опциональной цепочки ?. имеет три формы:

// obj?.prop – возвращает obj.prop, если существует obj, и undefined в противном случае.
// obj?.[prop] – возвращает obj[prop], если существует obj, и undefined в противном случае.
// obj.method?.() – вызывает obj.method(), если существует obj.method, в противном случае возвращает undefined.
// т.е. ?. проверяет левую часть выражения на равенство null/undefined,
// и продолжает дальнейшее вычисление, только если это не так.


// !_________________________Тип данных Symbol
//? Символ (symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов.

// Символы гарантированно уникальны. Даже если мы создадим множество символов
// с одинаковым описанием, это всё равно будут разные символы. 

// существует глобальный реестр символов. Мы можем создавать в нём символы и 
// обращаться к ним позже, и при каждом обращении нам гарантированно будет возвращаться один и тот же символ.
//?__________________________Symbol.for(key)
// читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан

// читаем его снова и записываем в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");

// проверяем -- это один и тот же символ
alert(id === idAgain); // true

//?__________________________Symbol.keyFor(sym)
// Для глобальных символов, кроме Symbol.for(key), который ищет символ по имени, 
// существует обратный метод: Symbol.keyFor(sym), который, 
// наоборот, принимает глобальный символ и возвращает его имя.

// получаем символ по имени
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// получаем имя по символу
alert(Symbol.keyFor(sym)); // name
alert(Symbol.keyFor(sym2)); // id


// !_________________________Преобразование объектов в примитивы

// Существуют три варианта преобразований («три хинта»), описанные в спецификации:

//* "string"
// Для преобразования объекта к строке, когда операция ожидает получить строку, например alert:

// вывод
alert(obj);

// используем объект в качестве имени свойства
anotherObj[obj] = 123;

//* "number"
// Для преобразования объекта к числу, в случае математических операций:

// явное преобразование
let num = Number(obj);

// математическое (исключая бинарный оператор "+")
let n = +obj; // унарный плюс
let delta = date1 - date2;

// сравнения больше/меньше
let greater = user1 > user2;

//* "default"
// Происходит редко, когда оператор «не уверен», какой тип ожидать.
// Например, бинарный плюс + может работать с обоими типами: строками(объединять их)
// и числами(складывать).Таким образом, и те, и другие будут вычисляться.
// Или когда происходит сравнение объектов с помощью нестрогого равенства == со строкой,
// числом или символом, и неясно, какое преобразование должно быть выполнено.

// бинарный плюс
let total = car1 + car2;

// obj == string/number/symbol
if (user == 1) { ... };


//?__________________________Универсальное преобразование

let user = {
    name: "John",
    money: 1000,

    [Symbol.toPrimitive](hint) {
        console.log(`hint: ${hint}`);
        return hint == "string" ? `{name: "${this.name}"}` : this.money;
    }
};

// демонстрация результатов преобразований:
console.log(user); // hint: string -> {name: "John"}
console.log(+user); // hint: number -> 1000
console.log(user + 500); // hint: default -> 1500


// !_________________________Числа
//?__________________________Округление

// Округление в меньшую сторону: 3.1 становится 3, а - 1.1 — -2.
Math.floor

// Округление в большую сторону: 3.1 становится 4, а - 1.1 — -1.
Math.ceil

// Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а - 1.1 — -1.
Math.round

// Производит удаление дробной части без округления: 3.1 становится 3, а - 1.1 — -1.
Math.trunc //(не поддерживается в Internet Explorer)

// Метод toFixed(n) округляет число до n знаков после запятой и возвращает строковое представление результата.
let numz = 12.34;
alert(numz.toFixed(1)); // "12.3"

//?__________________________Проверка: isFinite и isNaN
// преобразует значение в число и проверяет является ли оно NaN:
isNaN(value)

// преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity
isFinite(value)


// !_________________________Строки
//?__________________________str.includes(substr, pos)
// Метод возвращает true, если в строке str есть подстрока substr, либо false, если нет

//?__________________________str.startsWith и str.endsWith
// Методы проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой:

alert("Widget".startsWith("Wid")); // true, "Wid" — начало "Widget"
alert("Widget".endsWith("get")); // true, "get" — окончание "Widget"

//?__________________________Получение подстроки
// В JavaScript есть 3 метода для получения подстроки: substring, substr и slice.


// !_________________________ДЕСТРУКТУРИРУЮЩЕЕ ПРИСВАИВАНИЕ
//?__________________________Деструктуризация массива

// у нас есть массив с именем и фамилией
let arrr = ["Ilya", "Kantor"]

// деструктурирующее присваивание
// записывает firstName=arr[0], surname=arr[1]
let [firstName, surname] = arrr;

//?__________________________Значения по умолчанию

// Если в массиве меньше значений, чем в присваивании, то ошибки не будет.
// Отсутствующие значения считаются неопределёнными:
let [firstName, surname] = [];

alert(firstName); // undefined
alert(surname); // undefined

// Если нам необходимо указать значения по умолчанию, то мы можем использовать "=":
// значения по умолчанию
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

// Значения по умолчанию могут быть гораздо более сложными выражениями или даже функциями. 
// Они выполняются, только если значения отсутствуют.

// prompt запустится только для surname
let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];

//?__________________________Деструктуризация объекта
// Деструктурирующее присваивание также работает с объектами.
let options = {
    title: "Menu",
    width: 100,
    height: 200
};

let { title, width, height } = options;

// Если мы хотим присвоить свойство объекта переменной с другим названием, 
// например, свойство options.width присвоить переменной w, 
// то мы можем использовать двоеточие. Двоеточие показывает «что : куда идёт».
let { width: w, height: h, title } = options;

// Для потенциально отсутствующих свойств мы можем установить значения по умолчанию
let options = {
    title: "Menu"
};

let { width: w = 100, height: h = 200, title } = options;

//?__________________________Вложенная деструктуризация

// Если объект или массив содержит другие вложенные объекты или массивы, 
// то мы можем использовать более сложные шаблоны с левой стороны, 
// чтобы извлечь более глубокие свойства.
// В приведённом ниже коде options хранит другой объект в свойстве size и массив 
// в свойстве items. Шаблон в левой части присваивания имеет такую же структуру, 
// чтобы извлечь данные из них:
let options = {
    size: {
        width: 100,
        height: 200
    },
    items: ["Cake", "Donut"],
    extra: true
};

// деструктуризация разбита на несколько строк для ясности
let {
    size: { // положим size сюда
        width,
        height
    },
    items: [item1, item2], // добавим элементы к items
    title = "Menu" // отсутствует в объекте (используется значение по умолчанию)
} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut


// !_________________________ДАТА

// Создать объект Date с заданными компонентами в местном часовом поясе.
// Обязательны только первые два аргумента.
// year должен состоять из четырёх цифр: значение 2013 корректно, 98 – нет.
// month начинается с 0 (январь) по 11 (декабрь).
new Date(year, month, date, hours, minutes, seconds, ms);

// Получить год (4 цифры)
getFullYear() //getUTCFullYear()

// Получить месяц, от 0 до 11.
getMonth() //getUTCMonth()

// Получить день месяца, от 1 до 31, что несколько противоречит названию метода.
getDate() //getUTCDay()

// Получить, соответственно, часы, минуты, секунды или миллисекунды.
getHours(), getMinutes(), getSeconds(), getMilliseconds()

// Вернуть день недели от 0 (воскресенье) до 6 (суббота). 
// Несмотря на то, что в ряде стран за первый день недели принят понедельник, 
// в JavaScript начало недели приходится на воскресенье.
getDay()

// Для заданной даты возвращает таймстамп – количество миллисекунд, 
// прошедших с 1 января 1970 года UTC+0.
getTime()

// Возвращает разницу в минутах между UTC и местным часовым поясом:
getTimezoneOffset()

// возвращает текущую метку времени.
Date.now()

// считывает дату из строки.
// Формат строки должен быть следующим: YYYY-MM-DDTHH:mm:ss.sssZ
// Необязательная часть 'Z' обозначает часовой пояс в формате +-hh:mm. 
// Если указать просто букву Z, то получим UTC+0
// Возможны и более короткие варианты, например, YYYY-MM-DD или YYYY-MM, или даже YYYY.
Date.parse(str)


// !_________________________ПЛАНИРОВАНИЕ

setTimeout
// позволяет вызвать функцию один раз через определённый интервал времени.

let timerId = setTimeout(func | code, [delay], [arg1], [arg2], ...)
// func|code
// Функция или строка кода для выполнения. Обычно это функция. 
// По историческим причинам можно передать и строку кода, но это не рекомендуется.

// delay
// Задержка перед запуском в миллисекундах (1000 мс = 1 с). Значение по умолчанию – 0.

// arg1, arg2…
// Аргументы, передаваемые в функцию

setInterval
// позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.
// метод setInterval имеет такой же синтаксис как setTimeout
// чтобы остановить дальнейшее выполнение функции, необходимо вызвать clearInterval(timerId).
